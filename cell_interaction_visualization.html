<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cell Interaction Analysis Methods Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .controls {
            text-align: center;
            margin-bottom: 30px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            align-items: center;
        }
        
        .btn {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white;
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(245, 87, 108, 0.4);
        }
        
        .btn-success {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 172, 254, 0.4);
        }
        
        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .slider {
            width: 150px;
        }
        
        .visualization-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .canvas-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        
        .canvas-container:hover {
            transform: translateY(-5px);
        }
        
        .canvas-container h3 {
            margin-top: 0;
            color: #2c3e50;
            text-align: center;
            font-size: 1.4em;
            margin-bottom: 15px;
        }
        
        canvas {
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            width: 100%;
            height: 400px;
            cursor: crosshair;
        }
        
        .stats-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .stat-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .animation-controls {
            text-align: center;
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        @media (max-width: 768px) {
            .visualization-area {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .slider-group {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß¨ Cell Interaction Analysis Methods Visualization</h1>
        
        <div class="controls">
            <button class="btn btn-primary" onclick="generateRandomCells()">üé≤ Generate Random Cells</button>
            <button class="btn btn-secondary" onclick="generateClusteredCells()">üéØ Generate Clustered Cells</button>
            <button class="btn btn-success" onclick="clearCells()">üßπ Clear Canvas</button>
            
            <div class="slider-group">
                <label>KNN K-value:</label>
                <input type="range" class="slider" id="kSlider" min="3" max="20" value="10" onchange="updateK(this.value)">
                <span id="kValue">10</span>
            </div>
            
            <div class="slider-group">
                <label>Animation Speed:</label>
                <input type="range" class="slider" id="speedSlider" min="100" max="2000" value="500" onchange="updateSpeed(this.value)">
                <span id="speedValue">500ms</span>
            </div>
        </div>
        
        <div class="animation-controls">
            <button class="btn btn-primary" onclick="startDelaunayAnimation()">üî∫ Delaunay Animation</button>
            <button class="btn btn-secondary" onclick="startKNNAnimation()">üï∏Ô∏è KNN Animation</button>
            <button class="btn btn-success" onclick="stopAnimation()">‚èπÔ∏è Stop Animation</button>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>
        </div>
        
        <div class="visualization-area">
            <div class="canvas-container">
                <h3>üî∫ Delaunay Triangulation Method</h3>
                <canvas id="delaunayCanvas" width="500" height="400"></canvas>
            </div>
            
            <div class="canvas-container">
                <h3>üï∏Ô∏è K-Nearest Neighbors Method</h3>
                <canvas id="knnCanvas" width="500" height="400"></canvas>
            </div>
        </div>
        
        <div class="stats-container">
            <h3 style="text-align: center; color: #2c3e50; margin-bottom: 20px;">üìä Interaction Statistics Comparison</h3>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-number" id="delaunayConnections">0</div>
                    <div class="stat-label">Delaunay Connections</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="knnConnections">0</div>
                    <div class="stat-label">KNN Connections</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="interactionTypes">0</div>
                    <div class="stat-label">Interaction Type Pairs</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="similarityScore">0%</div>
                    <div class="stat-label">Method Similarity</div>
                </div>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #FF6B6B;"></div>
                <span>T Cell</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4ECDC4;"></div>
                <span>B Cell</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #45B7D1;"></div>
                <span>Macrophage</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #96CEB4;"></div>
                <span>NK Cell</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFEAA7;"></div>
                <span>Dendritic Cell</span>
            </div>
        </div>
    </div>

    <script>
        // ÂÖ®Â±ÄÂèòÈáè
        let cells = [];
        let k = 10;
        let animationSpeed = 500;
        let currentAnimation = null;
        let animationStep = 0;
        let maxSteps = 0;
        
        const cellTypes = [
            { name: 'T Cell', color: '#FF6B6B' },
            { name: 'B Cell', color: '#4ECDC4' },
            { name: 'Macrophage', color: '#45B7D1' },
            { name: 'NK Cell', color: '#96CEB4' },
            { name: 'Dendritic Cell', color: '#FFEAA7' }
        ];
        
        // Ëé∑ÂèñÁîªÂ∏É
        const delaunayCanvas = document.getElementById('delaunayCanvas');
        const knnCanvas = document.getElementById('knnCanvas');
        const delaunayCtx = delaunayCanvas.getContext('2d');
        const knnCtx = knnCanvas.getContext('2d');
        
        // ÂàùÂßãÂåñÁîªÂ∏ÉÁÇπÂáª‰∫ã‰ª∂
        delaunayCanvas.addEventListener('click', addCell);
        knnCanvas.addEventListener('click', addCell);
        
        // Ê∑ªÂä†ÁªÜËÉû
        function addCell(event) {
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left) * (canvas.width / rect.width);
            const y = (event.clientY - rect.top) * (canvas.height / rect.height);
            
            const cellType = cellTypes[Math.floor(Math.random() * cellTypes.length)];
            cells.push({ x, y, type: cellType.name, color: cellType.color });
            
            drawBothMethods();
            updateStats();
        }
        
        // ÁîüÊàêÈöèÊú∫ÁªÜËÉû
        function generateRandomCells() {
            cells = [];
            const numCells = 30 + Math.floor(Math.random() * 20);
            
            for (let i = 0; i < numCells; i++) {
                const x = 50 + Math.random() * 400;
                const y = 50 + Math.random() * 300;
                const cellType = cellTypes[Math.floor(Math.random() * cellTypes.length)];
                cells.push({ x, y, type: cellType.name, color: cellType.color });
            }
            
            drawBothMethods();
            updateStats();
        }
        
        // ÁîüÊàêËÅöÈõÜÁªÜËÉû
        function generateClusteredCells() {
            cells = [];
            
            // ‰∏∫ÊØèÁßçÁªÜËÉûÁ±ªÂûãÂàõÂª∫ËÅöÈõÜ‰∏≠ÂøÉ
            cellTypes.forEach((cellType, index) => {
                const centerX = 100 + (index % 3) * 150;
                const centerY = 100 + Math.floor(index / 3) * 150;
                const numCells = 8 + Math.floor(Math.random() * 5);
                
                for (let i = 0; i < numCells; i++) {
                    const angle = (Math.PI * 2 * i) / numCells + Math.random() * 0.5;
                    const distance = 30 + Math.random() * 40;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    
                    if (x > 20 && x < 480 && y > 20 && y < 380) {
                        cells.push({ x, y, type: cellType.name, color: cellType.color });
                    }
                }
            });
            
            drawBothMethods();
            updateStats();
        }
        
        // Ê∏ÖÁ©∫ÁªÜËÉû
        function clearCells() {
            cells = [];
            clearCanvas(delaunayCtx);
            clearCanvas(knnCtx);
            updateStats();
        }
        
        // Êõ¥Êñ∞KÂÄº
        function updateK(value) {
            k = parseInt(value);
            document.getElementById('kValue').textContent = k;
            drawBothMethods();
            updateStats();
        }
        
        // Êõ¥Êñ∞Âä®ÁîªÈÄüÂ∫¶
        function updateSpeed(value) {
            animationSpeed = parseInt(value);
            document.getElementById('speedValue').textContent = value + 'ms';
        }
        
        // Ê∏ÖÁ©∫ÁîªÂ∏É
        function clearCanvas(ctx) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        }
        
        // ÁªòÂà∂ÁªÜËÉû
        function drawCells(ctx) {
            cells.forEach(cell => {
                ctx.fillStyle = cell.color;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            });
        }
        
        // Delaunay‰∏âËßíÂâñÂàÜ
        function computeDelaunay() {
            if (cells.length < 3) return [];
            
            // ÁÆÄÂåñÁâàDelaunayÂÆûÁé∞ÔºàÂÆûÈôÖÂ∫îÁî®‰∏≠Âª∫ËÆÆ‰ΩøÁî®‰∏ì‰∏öÂ∫ìÔºâ
            const triangles = [];
            const points = cells.map(cell => [cell.x, cell.y]);
            
            // ‰ΩøÁî®Bowyer-WatsonÁÆóÊ≥ïÁöÑÁÆÄÂåñÁâàÊú¨
            // ËøôÈáå‰∏∫ÊºîÁ§∫ÁõÆÁöÑ‰ΩøÁî®ÁÆÄÂåñÂÆûÁé∞
            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    for (let k = j + 1; k < points.length; k++) {
                        triangles.push([i, j, k]);
                    }
                }
            }
            
            return triangles.slice(0, Math.min(triangles.length, points.length * 2));
        }
        
        // KNNËÆ°ÁÆó
        function computeKNN() {
            const connections = [];
            
            cells.forEach((cell, i) => {
                // ËÆ°ÁÆóÂà∞ÂÖ∂‰ªñÊâÄÊúâÁªÜËÉûÁöÑË∑ùÁ¶ª
                const distances = cells.map((otherCell, j) => {
                    if (i === j) return { index: j, distance: Infinity };
                    const dx = cell.x - otherCell.x;
                    const dy = cell.y - otherCell.y;
                    return { index: j, distance: Math.sqrt(dx * dx + dy * dy) };
                });
                
                // ÊåâË∑ùÁ¶ªÊéíÂ∫èÂπ∂ÂèñÂâçk‰∏™
                distances.sort((a, b) => a.distance - b.distance);
                const neighbors = distances.slice(0, Math.min(k, distances.length));
                
                neighbors.forEach(neighbor => {
                    if (neighbor.distance !== Infinity) {
                        connections.push([i, neighbor.index]);
                    }
                });
            });
            
            return connections;
        }
        
        // ÁªòÂà∂Delaunay
        function drawDelaunay() {
            clearCanvas(delaunayCtx);
            drawCells(delaunayCtx);
            
            const triangles = computeDelaunay();
            
            delaunayCtx.strokeStyle = 'rgba(102, 126, 234, 0.6)';
            delaunayCtx.lineWidth = 2;
            
            triangles.forEach(triangle => {
                const [i, j, k] = triangle;
                if (i < cells.length && j < cells.length && k < cells.length) {
                    delaunayCtx.beginPath();
                    delaunayCtx.moveTo(cells[i].x, cells[i].y);
                    delaunayCtx.lineTo(cells[j].x, cells[j].y);
                    delaunayCtx.lineTo(cells[k].x, cells[k].y);
                    delaunayCtx.closePath();
                    delaunayCtx.stroke();
                }
            });
            
            return triangles;
        }
        
        // ÁªòÂà∂KNN
        function drawKNN() {
            clearCanvas(knnCtx);
            drawCells(knnCtx);
            
            const connections = computeKNN();
            
            knnCtx.strokeStyle = 'rgba(245, 87, 108, 0.6)';
            knnCtx.lineWidth = 2;
            
            connections.forEach(connection => {
                const [i, j] = connection;
                if (i < cells.length && j < cells.length) {
                    knnCtx.beginPath();
                    knnCtx.moveTo(cells[i].x, cells[i].y);
                    knnCtx.lineTo(cells[j].x, cells[j].y);
                    knnCtx.stroke();
                }
            });
            
            return connections;
        }
        
        // ÁªòÂà∂‰∏§ÁßçÊñπÊ≥ï
        function drawBothMethods() {
            drawDelaunay();
            drawKNN();
        }
        
        // DelaunayÂä®Áîª
        function startDelaunayAnimation() {
            stopAnimation();
            if (cells.length < 3) {
                alert('Ëá≥Â∞ëÈúÄË¶Å3‰∏™ÁªÜËÉûÊâçËÉΩËøõË°åDelaunay‰∏âËßíÂâñÂàÜÊºîÁ§∫');
                return;
            }
            
            const triangles = computeDelaunay();
            maxSteps = triangles.length;
            animationStep = 0;
            
            currentAnimation = setInterval(() => {
                clearCanvas(delaunayCtx);
                drawCells(delaunayCtx);
                
                // ÁªòÂà∂Âà∞ÂΩìÂâçÊ≠•È™§ÁöÑÊâÄÊúâ‰∏âËßíÂΩ¢
                delaunayCtx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                delaunayCtx.lineWidth = 1;
                
                for (let i = 0; i < animationStep; i++) {
                    const triangle = triangles[i];
                    const [a, b, c] = triangle;
                    if (a < cells.length && b < cells.length && c < cells.length) {
                        delaunayCtx.beginPath();
                        delaunayCtx.moveTo(cells[a].x, cells[a].y);
                        delaunayCtx.lineTo(cells[b].x, cells[b].y);
                        delaunayCtx.lineTo(cells[c].x, cells[c].y);
                        delaunayCtx.closePath();
                        delaunayCtx.stroke();
                    }
                }
                
                // È´ò‰∫ÆÂΩìÂâç‰∏âËßíÂΩ¢
                if (animationStep < triangles.length) {
                    const currentTriangle = triangles[animationStep];
                    const [a, b, c] = currentTriangle;
                    if (a < cells.length && b < cells.length && c < cells.length) {
                        delaunayCtx.strokeStyle = '#667eea';
                        delaunayCtx.lineWidth = 3;
                        delaunayCtx.beginPath();
                        delaunayCtx.moveTo(cells[a].x, cells[a].y);
                        delaunayCtx.lineTo(cells[b].x, cells[b].y);
                        delaunayCtx.lineTo(cells[c].x, cells[c].y);
                        delaunayCtx.closePath();
                        delaunayCtx.stroke();
                        
                        // È´ò‰∫ÆÁõ∏ÂÖ≥ÁªÜËÉû
                        [a, b, c].forEach(idx => {
                            delaunayCtx.fillStyle = 'rgba(102, 126, 234, 0.3)';
                            delaunayCtx.beginPath();
                            delaunayCtx.arc(cells[idx].x, cells[idx].y, 12, 0, Math.PI * 2);
                            delaunayCtx.fill();
                        });
                    }
                }
                
                updateProgressBar();
                animationStep++;
                
                if (animationStep > maxSteps) {
                    stopAnimation();
                }
            }, animationSpeed);
        }
        
        // KNNÂä®Áîª
        function startKNNAnimation() {
            stopAnimation();
            if (cells.length < 2) {
                alert('Ëá≥Â∞ëÈúÄË¶Å2‰∏™ÁªÜËÉûÊâçËÉΩËøõË°åKNNÊºîÁ§∫');
                return;
            }
            
            maxSteps = cells.length;
            animationStep = 0;
            
            currentAnimation = setInterval(() => {
                clearCanvas(knnCtx);
                drawCells(knnCtx);
                
                if (animationStep < cells.length) {
                    const currentCell = cells[animationStep];
                    
                    // ËÆ°ÁÆóÂΩìÂâçÁªÜËÉûÁöÑÈÇªÂ±Ö
                    const distances = cells.map((otherCell, j) => {
                        if (animationStep === j) return { index: j, distance: Infinity };
                        const dx = currentCell.x - otherCell.x;
                        const dy = currentCell.y - otherCell.y;
                        return { index: j, distance: Math.sqrt(dx * dx + dy * dy) };
                    });
                    
                    distances.sort((a, b) => a.distance - b.distance);
                    const neighbors = distances.slice(0, Math.min(k, distances.length));
                    
                    // È´ò‰∫ÆÂΩìÂâçÁªÜËÉû
                    knnCtx.fillStyle = 'rgba(245, 87, 108, 0.3)';
                    knnCtx.beginPath();
                    knnCtx.arc(currentCell.x, currentCell.y, 15, 0, Math.PI * 2);
                    knnCtx.fill();
                    
                    // ÁªòÂà∂Âà∞ÈÇªÂ±ÖÁöÑËøûÊé•
                    knnCtx.strokeStyle = '#f5576c';
                    knnCtx.lineWidth = 3;
                    
                    neighbors.forEach((neighbor, idx) => {
                        if (neighbor.distance !== Infinity) {
                            const neighborCell = cells[neighbor.index];
                            
                            // Ê∏êÂèòÈÄèÊòéÂ∫¶ÊòæÁ§∫‰ºòÂÖàÁ∫ß
                            const alpha = 1 - (idx / neighbors.length);
                            knnCtx.strokeStyle = `rgba(245, 87, 108, ${alpha})`;
                            
                            knnCtx.beginPath();
                            knnCtx.moveTo(currentCell.x, currentCell.y);
                            knnCtx.lineTo(neighborCell.x, neighborCell.y);
                            knnCtx.stroke();
                            
                            // È´ò‰∫ÆÈÇªÂ±ÖÁªÜËÉû
                            knnCtx.fillStyle = `rgba(245, 87, 108, ${alpha * 0.3})`;
                            knnCtx.beginPath();
                            knnCtx.arc(neighborCell.x, neighborCell.y, 12, 0, Math.PI * 2);
                            knnCtx.fill();
                        }
                    });
                }
                
                updateProgressBar();
                animationStep++;
                
                if (animationStep > maxSteps) {
                    stopAnimation();
                }
            }, animationSpeed);
        }
        
        // ÂÅúÊ≠¢Âä®Áîª
        function stopAnimation() {
            if (currentAnimation) {
                clearInterval(currentAnimation);
                currentAnimation = null;
                animationStep = 0;
                drawBothMethods();
                updateProgressBar(0);
            }
        }
        
        // Êõ¥Êñ∞ËøõÂ∫¶Êù°
        function updateProgressBar(progress = null) {
            const progressBar = document.getElementById('progressBar');
            if (progress !== null) {
                progressBar.style.width = progress + '%';
            } else if (maxSteps > 0) {
                const percent = (animationStep / maxSteps) * 100;
                progressBar.style.width = Math.min(percent, 100) + '%';
            }
        }
        
        // Êõ¥Êñ∞ÁªüËÆ°‰ø°ÊÅØ
        function updateStats() {
            const delaunayTriangles = computeDelaunay();
            const knnConnections = computeKNN();
            
            // ËÆ°ÁÆó‰∫§‰∫íÁ±ªÂûãÂØπÊï∞
            const delaunayInteractions = new Set();
            const knnInteractionSet = new Set();
            
            delaunayTriangles.forEach(triangle => {
                const [i, j, k] = triangle;
                if (i < cells.length && j < cells.length && k < cells.length) {
                    const types = [cells[i].type, cells[j].type, cells[k].type];
                    for (let a = 0; a < types.length; a++) {
                        for (let b = a + 1; b < types.length; b++) {
                            const pair = [types[a], types[b]].sort().join('-');
                            delaunayInteractions.add(pair);
                        }
                    }
                }
            });
            
            knnConnections.forEach(connection => {
                const [i, j] = connection;
                if (i < cells.length && j < cells.length) {
                    const pair = [cells[i].type, cells[j].type].sort().join('-');
                    knnInteractionSet.add(pair);
                }
            });
            
            // ËÆ°ÁÆóÁõ∏‰ººÂ∫¶
            const commonInteractions = new Set([...delaunayInteractions].filter(x => knnInteractionSet.has(x)));
            const totalInteractions = new Set([...delaunayInteractions, ...knnInteractionSet]);
            const similarity = totalInteractions.size > 0 ? (commonInteractions.size / totalInteractions.size * 100).toFixed(1) : 0;
            
            document.getElementById('delaunayConnections').textContent = delaunayTriangles.length * 3;
            document.getElementById('knnConnections').textContent = knnConnections.length;
            document.getElementById('interactionTypes').textContent = totalInteractions.size;
            document.getElementById('similarityScore').textContent = similarity + '%';
        }
        
        // ÂàùÂßãÂåñ
        generateClusteredCells();
    </script>
</body>
</html>